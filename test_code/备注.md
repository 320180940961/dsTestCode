目标点更改，读取gps信息，是获取当前gps信息，根据json经纬度信息，使小车实现自主运动

最后总版本
1、获取gps话题信息，
2、将当前坐标位置作为第一个经纬度坐标信息点，插入到1.json文件中，然后将json文件中的内容依次后移形成新文件，根据新文件的内容实现小车的移动

4_15: 更改插入代码，实现功能3


1. current_gps
current_gps 是一个变量，用于存储当前接收到的 GPS 数据。它是一个实例变量（self.current_gps），通常是一个 gps_filtered 类型的消息，包含以下字段：
latitude：纬度
longitude：经度
yaw：偏航角（方向角）
在代码中，current_gps 的值通过订阅 /gps/filtered 话题获取，并在回调函数 gps_callback 中更新
每次接收到新的 GPS 数据时，current_gps 就会被更新为最新的值。这个变量在后续的运动控制和路径规划中被广泛使用。

2. initial_point
initial_point 是一个变量，用于存储初始的 GPS 数据点。它通常是在程序启动时获取的第一个 GPS 数据点，并被用作运动序列的起始点。
这个变量在返航逻辑中非常重要，因为小车需要返回到初始位置。

3. stop_triggered
stop_triggered 是一个布尔变量，用于标记是否接收到停止指令。它在代码中被初始化为 False，并在接收到停止指令时被设置为 True

gps_callback、cmd_callback
gps_callback：
用于处理接收到的 GPS 数据，更新当前 GPS 位置并记录日志。
cmd_callback：
用于处理接收到的控制指令，特别是停止指令。当接收到停止指令时，记录当前位置并触发返航逻辑。


1. 接收 GPS 数据：
通过订阅 /gps/filtered 话题，获取小车的实时 GPS 数据（纬度、经度和偏航角）。
将接收到的 GPS 数据存储在 self.current_gps 中。
2. 接收控制指令：
通过订阅 /Agrobot_cmd 话题，接收控制指令。指令中包含一个布尔值 stop，用于指示小车是否需要停止并返航。
3. 将当前 GPS 数据插入到 JSON 文件：
在程序启动时，将当前接收到的 GPS 数据作为第一个点插入到指定的 JSON 文件中。
JSON 文件中存储了一系列的 GPS 坐标点，这些点定义了小车的运动路径。
4. 计算运动序列：
根据 JSON 文件中的 GPS 坐标点，计算小车从一个点到下一个点的运动参数（速度和转向角）。
运动参数通过 compute_motion_params 方法计算，该方法使用了简单的几何计算来确定小车的转向角。
5. 控制小车运动：
使用 BasePlateCommand 类，根据计算出的运动序列，控制小车的运动。
控制小车先旋转到目标方向，然后直线行驶到目标点。
6. 停止并返航：
当接收到停止指令时，记录当前 GPS 位置，并将当前位置和初始位置作为新的运动序列，使小车返回到起始点。
7. 记录停止点：
在接收到停止指令时，将当前 GPS 数据记录到日志文件中，方便后续分析。


状态一：记录模式
状态二：导航模式（序列名、方向）
记录序列名称，（初始状态），回航，暂停[2.1]move_to跟数组 去邻近节点，继续工作
2.1.2 状态机record nave move
# 
# Stat1: RECORD ()
# Stat2: Nav (ListName, Dir)
# - In Stat2, Stat2.1 : PAUSE
# - In Stat2.1, 
# -- Stat 2.1.1 MoveTo
# -- Stat 2.1.2 ContNav (Dir) : -> Swtich Stat2

重定向

新增：
记录模式、使用键盘记录关键点，新建json文件记录点的信息，根据键盘输入新建点
    添加、插入、删除
监听模式：键盘敲入：四个模式，该状态使用的指定json文件内容
    出是模式为暂停（闲置）、移动到指定点、回航、继续原来工作
    可以直接根据键盘输入目标点编号，然后车可以移动到编号处
    初始点、stop点都加载在列表中，不更改json文件
输出状态记录：输出停止点的位置信息，正在前往那个点。

记录模式和监听模式分开工作（锁）

使用多线程：
创建一个主线程用于控制模式的切换。
创建三个子线程分别运行mode1、mode2和mode3。
使用线程同步机制（如threading.Event）来控制模式的启动和停止。
优先级控制：
stop模式拥有最高优先级，当stop模式被触发时，其他模式应立即停止。
使用一个全局标志变量（如stop_event）来控制其他模式的运行状态。
互不干扰：
三个模式在运行时互不干扰，每个模式在自己的线程中独立运行。
每个模式通过检查全局标志变量来决定是否继续运行。

方法二：
使用threading.Event：
创建一个全局事件stop_event，用于控制线程的停止。
每个线程在运行时会定期检查这个事件的状态。
当stop_event被设置时，所有线程都会停止运行。
线程独立运行：
四个模式线程独立运行，互不干扰。
每个线程通过检查stop_event来决定是否继续运行。
主控制线程：
主线程负责接收用户输入或信号，触发stop_event，从而停止所有线程。



根据以上代码的格式，帮会我写一个新的代码，分为两种功能：
功能一:记录模式，使用键盘记录关键点，新建json文件记录点的信息，根据键盘输入新建点，具有添加、插入、删除的功能，键盘输入a表示添加，b表示插入，c表示删除（添加的意思是从最后加入，插入则是按邻近点的顺序插入）在使用记录模式时，首先询问要新建的文件名，然后根据输入的文件名的json文件用于存储标记点的信息，文件就存储在和代码同级的目录下。
功能二：监听模式，在没有收到stop信号下，小车都是正常的根据json文件中的经纬度坐标信息功能，直到接收到stop信息小车停止运动，停止后根据键盘敲入的四个模式1、2、3、4，1是闲置模式，2是移动到指定目标点模式，3是回航模式，4是继续工作模式，进入以下四个模式后，仍然可以stop，但四个工作模式相互独立，收到stop信号后如果没有键盘输入，则一直等待键盘输入，默认状态1。代码格式：使用threading.Event：创建一个全局事件stop_event，用于控制线程的停止。每个线程在运行时会定期检查这个事件的状态。当stop_event被设置时，所有线程都会停止运行。线程独立运行：四个模式线程独立运行，互不干扰。每个线程通过检查stop_event来决定是否继续运行。主控制线程：主线程负责接收用户输入或信号，触发stop_event，从而停止所有线程。键盘敲入空格为stop信号。
执行代码前需要询问使用记录模式还是监听模式，记录模式相对应的键盘敲入1，监听模式键盘敲入2.

做一个输出、检查json名字冲突